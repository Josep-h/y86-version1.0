# README

by
​	解润芃
​	朱明哲

---

## Introduction to y86 simulator version 1.0

y86模拟器第一版使用cpp作为底层文件。



---

## 实现部分

###硬件的模拟方法：

1. memory`(memory[])`：一个模拟以**字节**为单位（一个不超过0x200的数）的一个整形数组。在内存中，命令指令从0开始，RSP的值会被汇编码自动给定。在memory里面存储的所有数都是以字节的方式，每一个存入的数字默认为8字节。
2. register`(reg[])`：寄存器的模拟是以一个long long型的长为16数组的数组。其中存储的值具有正负号，并且是通过fetch阶段自动转成一个整型数。特殊的其中%reg为reg[4]，其余所有的值按照CSAPP上对于寄存器标号。
3. ALU：不对ALU模拟，直接使用逻辑运算，即“&”、“^”、“+”、“-”四个。
4. 流水线寄存器`freg,dreg,ereg,mreg,wreg`：流水线寄存器由几个特殊的封装类构成。其中保存的是流水线寄存器其应当保存的所有值，别无其他。
5. 线路上计算量`d,e,m,w`：线路计算量的值先保存在线路计算量中的值，以及从流水线寄存器获得的值。计算的结果值会在写入阶段进去流水线寄存器。
6. CC：CC值是由三个bool值，ZF，SF，OF保存。
7. 控制逻辑：对于bubble以及stall的控制保存在流水线寄存器freg,dreg,ereg,mreg,wreg中。
8. 其余如icode和ifun的表达形式按照CSAPP的标号。
9. Cnd：在mreg类中保存寄存器中的Cnd，并且在计算临时量e中保存有Cnd。
10. Stat：最终的Stat值保存在Stat中，其他的状态量的stat保存在寄存器类中。
11. 组合逻辑：其余的组合逻辑使用直接的语句执行，如SelectPC等。
12. 一些标号：特殊状态值HLT，ADR，INS保持CSAPP上的标号，以及NONE也保持其上标号。

### 流程的实现（按照时间顺序）：

1. 先通过decoder函数把指令存在memory中。
2. SelectPC阶段：从predPC以及组合电路中接受一个新的PC值。
3. 取指阶段、译码阶段、执行阶段、访存阶段、写回阶段`run_in_cons()`：这是各计算量值的中间量计算过程，这一步不会写进流水线寄存器而是会等待在寄存器外部。也不会写进内存，Cnd会在被设置。
4. 转发阶段：通过计算量的结果进行转发，使满足条件的旧的数值更新。
5. 控制阶段：通过目前的计算量的中间量设置bubble和stall值，并且更改set_cc值。
6. 时间上升沿到达
7. 写入阶段：将流水寄存器更新，依照set_cc，bubble和stall，以及计算量的情况。
8. 重复以上过程直到出现错误状态我这HLT条件。
9. 输出结果，停机。

---

## 如何使用？

---

## 包含文件

---

1. 源代码：
2. 可执行文件（终端版）：
3. 可执行文件（界面版）：

## Reference

CSAPP。





